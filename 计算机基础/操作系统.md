# 操作系统

## CPU

并行和并发：

- 并行是多个操作在同一时刻发生；并发是在一段时间内，宏观上有多个程序共同运行，微观上还是交替执行。
- 并行需要处理器硬件的支持，并发只需要操作系统支持多任务调度。

CPU 和外部设备的交互，中断和轮询的区别：

- 中断指的是 CPU 监听内部或外部事件，出现事件后中断正在运行的程序，转到响应的服务程序去处理；轮询是定时向各个设备查询是否有处理需求。
- 中断的效率更高，响应更及时，现代计算机都是使用的中断。

## 锁

信号量（Semaphore）机制：

- PV 操作：P 获取资源；V 释放资源。
- `S>=0`，表示可用资源数量；`S<0` 表示等待资源的进程数。

信号量和互斥量区别：

- 互斥量值只能是 `0/1`，信号量值可以为非负整数。
- 互斥量代表着一种所有权，只有拥有者本身可以释放，即加锁和解锁必须由同一个线程。信号量代表可以使用的资源数量，可以由一个线程申请，另外一个线程释放。因此互斥量和二元信号量也是有区别的。

临界资源和临界区：

- 临界资源指每次只能被一个进程访问的资源，访问临界资源的那段代码就是临界区。

什么是死锁？

- 死锁产生的四个条件：互斥，竞争临界资源；请求和保持，请求其他资源阻塞时，不释放当前资源；不可剥夺；循环等待。

如何避免死锁？

- 针对循环等待，可以通过顺序加锁，避免形成环。
- 针对请求和保持，可以通过超时加锁，来释放资源。
- 针对不可剥夺：可以检测到死锁后，回滚操作，强制释放资源。

## 进程和线程

进程和线程的区别？

- 进程是操作系统资源分配的基本单位，线程是任务调度的基本单位。
- 一个进程可以有多个线程，多个线程可以并发执行，线程可以看做是轻量级的进程。
- 每个进程有自己的地址空间，线程共享该进程内的资源。创建线程的开销比进程小的多，创建进程需要操作系统分配新的地址空间、数据资源，而创建线程仅仅需要程序计数器、寄存器、栈空间。线程切换代价更小，通信更方便。

进程通信的方式：

- 无名管道（父子进程）、命名管道（任何进程）。管道的通信是半双工的。
- 共享内存&信号量
- 信号
- 消息队列：内核提供一个共享的链表。
- Socket

线程通信的方式：

- 互斥量
- 信号量
- 事件（信号）

进程的五态模型：

- 新建态：创建进程，分配需要的资源和空间，置为就绪态。
- 就绪态：可以运行，但是还没有分配时间片。
- 运行态：占用 CPU 时间片，正在运行中。
- 阻塞态（睡眠态）：等待某事件的发生而不能执行，事件发生后转为就绪态。
- 终止态：进程已执行完毕，等待释放资源。

Linux 系统下进程的状态：

- R (TASK_RUNNING)：可执行。对应进程的就绪态和运行态。
- S (TASK_INTERRUPTIBLE)：可中断睡眠。等待某事件的发生，如 Socket 连接、信号量等，对应进程的阻塞态。
- D (TASK_UNINTERRUPTIBLE)：不可中断睡眠。进程不响应异步信号，主要是内核处理某些流程是不可以中断的，对应进程的阻塞态。
- T (TASK_STOPPED)：暂停状态。如调试器调试。
- Z (TASK_DEAD - EXIT_ZOMBIE)：退出状态，僵尸进程。进程的资源已经被回收，但是 task_struct 还在，保存了进程的一些信息，父进程应该调用 `wait` 来等待子进程退出并获取信息，系统就会正确的处理子进程的“尸体”。
- X (TASK_DEAD - EXIT_DEAD)：退出状态，进程即将被销毁。这个状态很短暂，基本上不会被 ps 捕捉到。

进程自创建以后，状态可能发生一系列的变化，但是变迁只有两个方向，从 R 转为其他状态，和从其他状态转为 R 状态。

## IO 模型

阻塞IO和非阻塞IO：

- 阻塞IO：发起 IO 调用后，进程被阻塞，转移到内核空间，等 IO 处理完毕后返回。
- 非阻塞IO：发起 IO 调用后，如果缓冲区没有数据，返回一个错误而不是阻塞。

同步IO和异步IO：

- 同步IO：发起 IO 调用后，处理完成后返回，然后由应用负责 IO 的具体处理。
- 异步IO：发起 IO 调用后立刻返回，由内核负责 IO 的处理，完成后回调进程进行处理。

可以看到`同步/异步`和`阻塞/非阻塞`没有必然的关系，同步也可以是非阻塞的，比如将 Socket 设为 NONBLOCK 进行读写。

IO多路复用：

- 将多个 IO 注册到一个复用器（select）上，进程监听该 select，该 select 监听所有注册的 IO。
- 相当于将多个 IO 的调用阻塞（或非阻塞，立刻返回）在一个复用器的调用上。Reactor 模式，适用于高并发服务应用开发。

IO 多路复用调用中，select、poll、epoll 区别：

- select：
  - 使用一个固定大小的数组作为参数，用位来表示一个 fd，因此支持的 fd 数量最大为 1024 个。每次都需要进行用户态到内核态拷贝。
  - 只返回就绪的数量，具体就绪的结果也存在 fd 参数数组中，所以需要清空设置监听的 fd 位信息。
- poll：
  - 使用结构体数组作为参数，解决了能监听的 fd 大小限制问题。但还是需要每次用户态到内核态的拷贝。
  - 返回的结果设置结构体中的一个参数，避免了每次清空参数问题。但还是需要用户去遍历这个数组找到就绪事件。
  - 只支持水平触发。
- epoll：
  - 分为三个方法 `epoll_create/epoll_ctl/epoll_wait`，`epoll_create` 创建一个 eventpoll 结构体返回；`epoll_ctl` 管理关注的事件；`epoll_wait` 阻塞或非阻塞的获取就绪事件。
  - 只有 `epoll_ctl` 的时候需要在用户态/内核态拷贝 fd 信息，避免了每次获取都需要拷贝。
  - eventpoll 结构体使用红黑树存储关注的 fd 事件；使用双向链表存储就绪的事件。
  - 同时支持水平触发（LT）和边缘触发（ET）。边缘触发主要用于当有你不需要读写的 fd 时候，不会每次都返回给你。

Reactor 和 Proactor 区别：

- Reactor：调用返回就绪的IO事件，应用自己去读写；同步非阻塞IO。
- Proactor：指定读写的内存位置，操作系统负责读取到指定内存再回调应用的处理器；异步非阻塞IO。

## 内存管理

虚拟内存是操作系统内存管理的一种技术，它使得应用程序认为它拥有连续可用的内存（连续完整的内存空间），而实际上它通常被分割为多个物理内存碎片，还有部分存在磁盘上，在需要时进行数据交换。内存管理单元（MMU），使用页表（Page Table）负责 Virtual Page 到物理地址间的转换。

虚拟内存的优点：

- 结合硬盘和物理内存的优势，提供速度足够快并且容量足够大的存储。
- 简化了程序的链接、装载、内存分配。
- 控制进程对内存的访问，隔离不同进程的权限。

Linux 中使用 fork 创建子进程时，只**复制父进程**的页表，提供写时复制机制。

内存分段是指在用户使用内存时，在虚拟内存上再拆分出来一层逻辑的虚拟层，将内存声明为几个独立的段，方便程序的编写。

内存分页与分段的区别：

- 分页：
  - 分页是操作系统管理物理内存的机制，对用户是透明的，向用户提供一维的空间地址。
  - 页的信息是物理单位，页大小是固定的。
- 分段：
  - 分段是从用户的视角来分割内存的机制，如将程序的地址空间划分为若干独立而不干扰的段（代码段、数据段、堆栈段），向用户提供二维的空间地址。
  - 段的信息是逻辑单位，段大小是不固定的。

## 文件管理

Linux EXT 文件系统：

- 文件系统通过 `inode` 和 `block`。每个文件有一个 `inode`(128B)，包含了文件权限、创建信息、对应的 `block` 编号。`block` 用来存储文件的数据，如果直接引用到的 `block` 存不下来完整的文件，可以在 `block` 中继续多层引用其他 `block`。
- 目录至少包含一个 `inode` 和 `block`，`inode` 记录了目录的相关权限和属性、对应的 `block` 编号，`block` 存放了目录下的文件名和对应的 `inode`。
