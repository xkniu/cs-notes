# 设计模式

设计模式是什么？

设计模式的概念源于建筑设计大师 Christopher Alexander 的《建筑的永恒之道》，书中是这样定义的：“模式是一条由三个部分组成的通用规则：它表示了一个特定环境、一类问题和一个解决方案之间的关系。每一个模式描述了一个不断重复发生的问题，以及该问题解决方案的核心设计。”

可以看到设计模式是一种抽象的思想，它将不断重复发生的问题和其解决方案抽象为模式，以方便下次遇到相同场景的时候能够复用。由此可见，设计模式的主要优点有：

- 对于重复问题的抽象，减少了解决相同问题时再次劳动的复杂度，就是说增加了可重用性。
- 将问题抽象出来后，人们就可以更容易的通过模式来沟通，能用简单的单词（想想「叫得出名字的优美设计」那种感觉）来描述和传递一个复杂的场景，它提高了沟通的效率。

然而设计模式并不应该被滥用，一个有灵魂的建筑不是一堆模式的堆砌。模式应该是自然的，而不是刻意的。

> 以一种松散的方式把一些模式串接在一起来建造建筑是可能的。这样的建筑仅仅是一些模式的堆砌，而不紧凑。这不够深刻。然而另有一种组合模式的方式，许多模式重叠在同一个物理空间里：这样的建筑非常紧凑，在一小块空间里集成了许多内涵；由于这种紧凑，它变得深刻。
> —— 《建筑的永恒之道》

而软件中的设计模式就是将模式的概念应用于软件开发领域，是软件开发人员对开发中常见问题的一般解决方案。

## 设计模式的六大原则

| 原则 | 含义 | 概括 |
| --- | --- | --- |
| 单一职责原则（Single Responsibility Principle） | 一个类只负责一个职责 | 高内聚 |
| 里氏替换原则（Liskov Substitution Principle） | 子类应该可以替代父类 | 不要破坏类的继承体系 |
| 依赖倒置原则（Dependence Inversion Principle） | 依赖于抽象，不依赖于具体 | 面向接口编程 |
| 接口隔离原则（Interface Segregation Principle） | 依赖最小接口 | 接口划分粒度应该足够细 |
| 迪米特法则（Law of Demeter） | 对自己依赖的类知道越少越好 | 通过中间类产生联系，低耦合 |
| 开闭原则（Open Close Principle） | 对扩展开放，对修改关闭 | 设计的总纲，指导思想 |

一句话总结：面向细粒度接口编程，高内聚低耦合，可扩展又不违背继承体系。

## 常用的设计模式

创建型模式，提供创建对象时隐藏创建逻辑的方式，使得实例的创建更加灵活。主要有以下几种模式：

- 单例模式（Singleton）：全局唯一实例。常用静态内部类或者
- 工厂模式（Factory）：封装创建的逻辑，使用工厂方法获取实例。
- 抽象工厂模式（Abstract Factory）：创建相关的一组产品，工厂接口提供一组产品的工厂方法，并且提供多个工厂实现。
- 建造者模式（Builder）：方便构造复杂对象。通常可以通过构造函数和设置方法来区分必要参数和可选参数。
- 原型模式（Prototype）：通过克隆简化对象的创建。

结构型模式，关注类和对象的组合，继承概念被用来

- 适配器模式（Adaptor）：将一个接口适配成另外一个接口的实现。通常用于第三方代码包，不方便直接修改它的实现。
- 桥接模式（Bridge）
- 过滤器（Filter）：使用不同的标准来过滤一组对象，使用逻辑运算以解耦的方式连接起来。
- 组合模式（Composite）
- 装饰器模式（Decorator）：向一个现有的对象添加新的功能，又不改变其接口。实现同一个接口，并且持有一个要装饰对象的实例，在原方法前后添加一些功能增强的逻辑。
- 外观模式（Facade）：隐藏系统复杂性，向客户端提供简单接口。
- 享元模式（Flyweight）：共享对象来减少对象创建。比如字符串池、对象池之类的。
- 代理模式（Proxy）：为对象提供一种代理来访问对这个对象的访问。实现同一个接口，并且持有一个要代理对象的实例，在原方法前后添加一些访问控制的功能。

行为型模式，关注对象之间的通信。主要有以下几种模式：

- 责任链（Chain of Responsibility）：为请求创建一个处理者链。
- 命令模式（Command）
- 解析器模式（Interpreter）
- 迭代器模式（Iterator）：顺序访问集合对象的元素，不需要知道集合的底层表示。比如Java 中的 Iterator。
- 中介者模式（Mediator）
- 备忘录模式（Memento）
- 观察者模式（Observer）：当对象修改时，通知依赖它的对象。比如 Listener 机制。
- 状态模式（State）
- 空对象模式（Null Object）：用空对象取代用 null 的位置，提供默认的行为。
- 策略模式（Strategy）
- 模板（Template）：抽象类定义了执行它的模板，子类根据需要重写抽象方法。
- 访问者模式（Visitor）

## 设计模式实例

- [JDK 中的设计模式](https://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns-in-javas-core-libraries)
