# 计算机网络

计算机网络7层协议体系结构，从下往上依次是：

- 物理层：实现相邻计算机结点之间比特流的透明传输，尽量屏蔽到传输介质和物理设备差异。
- 数据链路层：建立相邻节点间的数据链路，通过查错控制提供数据帧在信道上的传输。
- 网络层：选择合适的网间路由和交换机，确保数据及时送达。主要协议有 IP、ARP、ICMP。
- 传输层：负责向两台主机进程之间提供数据传输服务。主要协议有 TCP、UDP。
- 会话层：在两节点之间建立、维持、终止通信。
- 表示层：数据的表示、安全、压缩等。
- 应用层：应用进程来完成特定的网络作用。主要协议有 DNS、HTTP、HTTPS 等。

简化的5层协议架构为：物理层、数据链路层、网络层、传输层、应用层。

各层的传输单位：

- 物理层：比特流（bit）
- 数据链路层：数据帧（frame）
- 网络层：数据包（packet）
- 传输层：数据段（segment），TCP 协议；数据报（datagram），UDP 协议。
- 应用层：消息/报文（message）

端口是传输层的概念，用来区分不同的应用进程。常用应用层协议端口：

- FTP: 21
- DNS: 53
- HTTP: 80
- HTTPS: 443

## 网络层协议

网络层实现主机之间的通信，而链路层实现的是链路间的通信。数据传输过程中，源和目的 IP 是不变的，但是 MAC 地址在不同的链路中一直在转变。

### ARP 协议

ARP (Address Resolution Protocol)，地址解析协议，主要作用是将 IP 地址转为 MAC 地址。工作流程如下：

- 如果 A 和 B 在一个局域网内，主机 A 向主机 B 发送 IP 数据报时，A 会查询本机的 ARP 缓存，是否有 IP 到 MAC 地址的映射。如果本机没有 B 的 ARP 缓存，则 A 会在局域网中广播，B 收到后会单播回复自己的 MAC 地址给 A，A 将结果进行缓存。
- 如果 A 和 B 不在同一个局域网中，则 A 需要先广播找到路由器的 MAC 地址，路由器再找到其他路由器的 MAC 地址，最后 B 所在路由器广播找到 B 的 MAC 地址。

有了 IP 地址，为什么还要 MAC 地址：

- IP 地址每台机器可以自行更改，MAC 地址每台设备是固定的。
- IP 地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，路由器通过 IP 前缀就知道设备在哪个子网上了，而只使用 MAC 地址的话，路由器需要知道每个 MAC 在哪个子网，数据量太大了，无法实现。

路由器和交换机的区别：

- 路由器属于网络层，识别 IP 地址并根据 IP 转发数据包。
- 交换机属于数据链路层，识别 MAC 地址并根据 MAC 地址转发数据帧。

### ICMP 协议

ICMP (Internet Control Message Protocol)，Internet 控制报文协议，是为了辅助 IP 协议，传递各种控制消息。

`ping` 命令就是通过发送 ICMP 消息，统计目的主机返回报文的时间和成功次数估算出数据包往返时间和丢包率。

## 传输层协议

### TCP 协议

TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 的区别：

- TCP 是面向连接的；UDP 是无连接的，传输前不需要建立连接。
- TCP 可供可靠的交付；UDP 不保证可靠性。
- TCP 面向字节流；UDP 面向数据报文。
- UDP 的传输效率更高一些，常用于数据不需要可靠的场景，可以部分丢失的场景，如视频直播。

TCP 怎么保证可靠传输？

- 校验和：发送端和接收端分别计算校验和，不一致说明传输中出现差错，丢弃。
- 序列号确认和超时重传：对发送的字节进行编号，接收端收到后会发送确认应答报文，告诉对方下一次发送的报文从哪里开始发。发送方发送后一段时间内没有收到 ACK，则进行重传。
- 流量控制：接收方可以通过**确认报文的窗口字段**控制发送方的发送速率，保证来得及接受，大小为接收端的数据缓冲区剩余的大小。滑动窗口是为了能够并发的发送数据字节，但是又能根据接收端的能力，限制它的最高并发量。
- 拥塞控制：发送方感知网络的负载情况，在网络拥塞时，主动降低发送速率来缓解网络阻塞状况。拥塞控制主要包含四个阶段：慢开始、拥塞避免、快重传、快恢复。
    - 慢开始：是从 `cwnd=1` 开始逐步提高发送报文个数，通过指数。
    - 拥塞避免：发送个数超过 `ssthresh` 后 `cwnd` 开始线性增长。直到发生网络阻塞后，将 `ssthresh` 调整为阻塞值的一半，`cwnd` 重新置为1. 这两个阶段就是在动态的试探网络的负载能力，并且尽量的让网络阻塞慢点到来。
    - 快重传：除了超时重传，接收方也可以连续重复3次 ACK 一个序列号，告诉发送方这个序列号数据丢失了，让发送方立刻开始重传。
    - 快恢复：快重传发生，说明有数据丢失，但是又不是太多，这时候跳过慢开始阶段，直接将 `ssthresh` 和 `cwnd` 都减半，开始拥塞避免阶段。

TCP 建立连接需要三次握手，需要确认客服端和服务端都具备收发的能力。三次握手的过程如下：

- 第一次握手：客户端发起建立连接请求，发送 `SYNC=1, seq=x`，发送完成后客户端进入 `SYN-SENT` 状态。
- 第二次握手：服务端收到报文后，回复 `SYNC=1, ACK=1, seq=y, ack=x+1`，回复后服务端进入 `SYN-RCVD` 状态。
- 第三次握手：客户端收到服务端回复后，回复 `ACK=1, ack=y+1`，回复后客户端进入 `ESTABLISHED` 状态，服务端收到后也进入 `ESTABLISHED` 状态。

TCP 断开连接需要四次挥手，由于连接是双工的，可以单向的关闭表示不再继续发送数据，但还可以继续接收。四次挥手的过程如下：

- 第一次挥手：假设关闭发起方为 A，接收方为 B，则 A 发送 `FIN=1, seq= x`，发送完成后 A 进入 `FIN-WAIT-1` 状态。
- 第二次挥手：B 收到 A 的报文后，回复 `ACK=1, seq=x+1`，发送完成后 B 进入 `CLOSE-WAIT` 状态；A收到后进入 `FIN-WAIT-2` 状态。
- 第三次挥手：B 也决定关闭连接，B 发送 `FIN=1, seq=y`，发送完成后 B 进入 `LAST-ACK` 状态。
- 第四次挥手：A 收到 B 的关闭报文后，回复 `ACK=1, ack=y+1`，发送完成后 A 进入 `TIME-WAIT` 状态，等待 2MSL 后进入 `CLOSED` 状态；B 收到后进入 `CLOSED` 状态。

为什么需要 `TIME-WAIT` 状态？

- 尽量保证双方都正常的关闭连接。如果 A 的 ACK 报文丢失，B 会重发 FIN 请求，A 再次收到 FIN 后重发 ACK，保证 B 能正确的关闭。
- 等待 2MSL，即2倍报文最大存活时间后，可以确认本次连接过程中的包都在网络中消息，不会影响到下次连接新的报文。第一个 MSL，确保自己发的 ACK 包已经失效；第二个 MSL，确保接收方在收到 ACK 前一瞬间可能重发了 FIN 包失效。

TCP 的保活机制：

- 常用于服务器端，可以检测对方状态，避免对方已经崩溃后，还保持着连接，占用资源。
- 设置 TCP 的 `keepIdle` 保活时间，TCP 在超过该时间没有收到任何数据交互后，发送保活探测报文，发送探测报文的间隔为 `keepInterval`，总发送次数为 `keepCount`，如果 `keepCount` 次保活报文均没有收到回复，则关闭连接。

SYN Flood 攻击：

- 半开放攻击是一种 DDoS 攻击，通过大量的客户端（或者伪造 IP）向服务端发送大量的 SYN 包建立 TCP 连接，在服务端产生大量的 `SYN-RCVD` 状态的连接（又成为半连接），占用大量服务器资源，最终无法正常工作。
- 解决方案：
    - 缩短 SYN timeout。
    - SYN Cookie：收到 SYN 请求报文后，不分配资源建立连接，而是根据报文的重要信息（包括源和目的 IP、端口），使用 hash 算法计算出一个哈希，用当前时间 t（缓慢增长，如60s）和哈希来生成 seq 号返回应答。在客户端回复 ACK 后，验证 ack 的 seq 的合法性，通过后再建立连接。
    - SYN Proxy 防火墙：通常也是使用 SYN Cookie 或者 SYN Cache 来验证连接的有效性。

## 应用层协议

### DNS 协议

DNS (Domain Name System) 采用分布式的层次数据库模式，用来查询域名对应的 IP 地址。

DNS 查询的两种模式：

- 递归模式：客户端只发一次请求，要求对方给出最终的结果。本机向本地 DNS 服务器查询一般是用递归模式。
- 迭代模式：客户端发请求后，对方返回下层 DNS 的地址，客户端继续迭代请求，直到拿到最终结果。本地 DNS 向根服务器查询一般是迭代模式。

### HTTP 协议

常用状态码分类：

- 2XX 成功
- 3XX 重定向：301永久重定向；302临时重定向。
- 4XX 客户端错误：400客户端参数错误；401客户端未认证；403拒绝提供服务；404页面不存在；405方法不支持。
- 5XX 服务器错误：500服务器内部错误；503当前不能处理请求。

长连接与短链接：

- HTTP 的长连接/短连接，本质上是 TCP 的长连接/短连接。
- HTTP/1.0 默认使用短连接，HTTP/1.1 之后默认使用长连接。可以通过请求头中设置 `Connection:keep-alive` 或者 `Connection:close` 来明确的开启或者关闭，响应头中可以明确返回（默认值也可以不返回）是否使用和对应的超时时间、允许的最大连接数，如 `Connection:keep-alive Keep-Alive:timeout=30,max=10`。
- 使用长连接时，网页访问完后，客户端不会关闭和服务端的 TCP 连接，再次访问服务器时会继续使用这条连接。如果长时间没有数据传输，超过超时时间后，服务端会关闭连接。

HTTP/2.0 原理：

- HTTP/2.0 使用二进制编码，将传输的消息（请求/响应）拆分为多个帧（HEADER 帧和数据帧），使用同一条 TCP 连接发送。流是连接中虚拟的信道，请求响应的帧可以乱序发送，使用流标识对应起来。
- HTTP/2.0 并没有改变 HTTP/1.x 的语义，只是使用二进制分帧进行传输。
- 多路复用共享连接：基于二进制分帧层，同一个 TCP 连接可以并发地乱序地传输多个数据流。
- 首部压缩：客户端和服务端维护一份静态字典（常用的头部名称值）和动态字典（请求过程中逐步创建），请求和回复的时候使用字典的 index 来减少传输数据量。
- 请求优先级：流中可以带一个 31 bit 的优先级，服务器可以根据流的优先级，优先把这些流的帧发送给客户端。
- 服务端推送：服务端对一个请求发多个响应，也可以在没有明确请求时主动推送。比如服务端估计需要请求的资源，在没有请求时提前推送过去，充分利用空闲网络，优化页面加载时间。

### HTTPS 协议

HTTPS 是在 TCP 协议上增加了 TLS  层，保证数据传输的安全性和完整性，防止了传输的冒充、窃听、篡改问题。

TLS (Transport Layer Security) 1.0 等价于 SSL (Secure Socket Layer) 3.1，历史上使用 SSL 名称，后来标准化后更名为 TLS。

HTTPS 交互的过程：

1. 客户端向服务端发送第一次握手请求，告诉服务客户端支持的 SSL 版本、加密算法和秘钥长度等信息。
2. 服务端将自己的数字证书和选择的加密算法发送给客户端。
3. 客户端验证数字证书的合法性，验证后获得服务端公钥。使用公钥加密自己生成的对称秘钥，发送给服务端。
4. 服务端收到后使用自己的私钥解密，获得对称秘钥。
5. 双方使用对称秘钥对传输内容进行对称加密（AES、DES），保证消息的机密性；并使用 HMAC 算法进程摘要，确保消息完整性。

HTTPS 为什么同时使用非对称加密和对称加密？

- 对称加密效率高，非对称加密效率较低。需要找到一个安全的方式将对称加密的秘钥传送给对方。
- 使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。

数字证书的原理：

- 数字证书用于客户端确认服务器身份，确保连接的是真的服务端，核心就是拿到真实服务端的公钥。数字证书通过信息摘要和非对称加密机制，发布不可伪造的信息。
- 证书里包含了证书的颁发者（CA）、有效期、持有者、持有者公钥、签名的哈希算法等信息，将这些信息用哈希算法算出摘要后，颁发者使用自己的 RSA 秘钥加密这串摘要生成数字签名。
- 客户端拿到证书后，通过颁发者的公钥验证数字签名的合法性即可。数字证书采用链式签名认证，即通过根证书 (ROOT CA) 去签名下一级证书，这样层层签名，直到最终的用户证书，根证书的公钥通常直接内置在了操作系统和浏览器中。

## 其他问题

Session、token 和 Cookie 的区别？

- Session 是服务端保存的会话状态；Token 是服务端找到对应会话状态的 key；Cookie 是返回给客户端，保存在浏览器的数据信息，下次请求时会自动发过来。

从输入 URL 到浏览器显示页面发生了什么？

1. 从本地 hosts 文件或者通过 DNS 解析，获取到域名的 IP 地址。
2. 建立到对应地址的 TCP 连接。
3. 与服务器交互创建 HTTPS 的 TLS 层。
4. 向目的服务器发送 HTTP 请求。
5. 服务器处理请求，并返回 HTTP 报文。
6. 浏览器解析并渲染页面。
7. 关闭与服务器的 TCP 连接。
