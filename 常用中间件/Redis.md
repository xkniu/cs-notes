# Redis

参考之前的《Redis 设计与实现笔记》，不列举过多的细节，主要总结核心概念和设计思想。

Redis 是一个使用 C 语言编写的，开源的高性能 NoSQL 数据库。它的主要优点有：

- 读写性能优异，单机可以支持 10w 左右 QPS。
- 支持丰富的数据结构。
- 支持集群（可扩展）和主从（高可用）。
- 支持持久化。
- 简单的事务支持。

为什么这么快？

- 读写完全基于内存。
- 数据结构简单。
- 单线程避免了线程切换和锁冲突。
- IO多路复用的 Reactor 模型，非阻塞 IO。

## 核心数据结构

Redis 内部使用 redisObject 对象来表示所有的 key/value。结构如下：

```c
typedef struct redisObject {
    unsigned type:4;    // 数据结构
    unsigned encoding:4;    // 对应的具体实现
    unsigned lru:LRU_BITS;  // LRU 时间
    int refcount;   // 引用计数
    void *ptr;  // 值的指针
} robj;
```

主要的数据结构（type）与对应的实现编码（encoding）有：

- String
  - SDS：动态字符串。记录了长度，会预分配空间和自动扩容。
- List
  - LinkedList：双向链表。
  - ZipList：压缩链表。用数组模拟双向链表，由于节点内存储内容长度不固定，节点中需要有节点大小和上个节点大小用于向后和向前遍历。优点是存储紧凑，节约空间。
- Hash
  - HashTable：哈希表。使用开放链路法解决冲突，自动扩容，负载因子根据是否有 fork 进程变化（1/5），减少有子进程时的内存占用，使用两个哈希表来支持渐进 rehash。
  - ZipList：压缩链表。只有在数据量少的时候采用，需要线性遍历，查询 `O(n)` 的时间。
- Set
  - HashTable：哈希表。
  - IntSet：可变编码的整数数组。只有在数据量较少，且数据都是整数时采用，用数组来支持 set，查询 `O(n)` 的时间。
- Sorted set，有序集合，除了集合特性，按照分值排序，方便范围获取：
  - SkipList + HashTable：跳表来根据分值查询，哈希表来支持快速键查询。
  - ZipList：压缩链表。只有在数据量比较少时采用，节约空间。

对于常见的字符串返回值，比如 "OK/ERROR" 和小整数字符串，Redis 使用 flyweight 模式共享对象。`refcount` 用于记录有多少地方引用了该对象，没有复杂嵌套，不会有循环引用，当为0时回收对象。

数据结构的使用场景：

- List：简单的消息队列。
- Hash：大对象的缓存，用 hash 可以部分更新。
- Set：支持集合的各种操作，用来做好友推荐、共同关注等。
- Zset：动态变化的排行榜。

## 单机数据库

### 过期 Key

数据库中使用两个分开的 hash 来存储正常的 key 和带有过期时间的 key。

过期 Key 策略：

- 惰性删除：读取的时候判断，确保正确性，内存不友好。
- 定期删除：serverCron 执行的时候抽样，删除其中过期的。

Redis 到最大内存，内存淘汰策略主要有：不淘汰报错、所有 key 里 LRU、带过期时间 key 里 LRU、所有 key 里随机、带过期时间 key 里随机、带过期时间里 TTL 最短。

Redis 的 LRU 是近似 LRU 算法，随机抽样一部分数据，淘汰空闲时间最大的 key，剩余的数据进入淘汰池，再继续随机抽样数据，抽样结果与淘汰池合并，并淘汰空闲时间最大的 key。Redis 使用近似 LRU 算法，可以避免了维护精确 LRU 链表所需要的额外空间，用较小的空间代价来换取一个还不错的近似效果，如果数据访问符合幂次分布，即大部分的访问几种在少部分键时，近似算法结果很好。

### 持久化

- RDB (Redis Dump Binary)：把内存里的数据快照写入磁盘，存为一个二进制文件 `dump.rdb`，根据配置定时超过阀值个修改则生成一次，是 Redis 默认的持久化方式。
  - 优点：很适合灾备，数据文件小，格式紧凑，恢复时间快。
  - 缺点：数据不够全，定时生成，可能丢失部分数据。
- AOF (Append Only File)：将所有的命令通过追加写的方式写到一个文件里，默认没开启。
  - 优点：实时性高，根据 fsync 策略（每次/每秒/不调用），可以做到丢最多一条或者丢失最多1s的数据。
  - 缺点：文件大，追加更新，有冗余无效数据；每次命令调用，会影响执行命令的效率。
- 混合持久化（4.0新增）：执行 `bgrewriteaof` 时，fork 子进程生成 AOF 文件，但是当前内存的数据通过 RDB 写到文件前面部分，之后该文件作为正常的 AOF 文件使用。
  - 优点：兼顾了数据的实时性和恢复效率。

RDB 通过 fork 子进程生成，利用操作系统的 copy-on-write 特性，只占有少量的额外内存。如果在生成过程中，如果修改命令的 QPS 很高，copy-on-write 也会占用大量的内存，可能导致大量使用磁盘 swap 或造成 OOM。

AOF 重写，通过 `bgrewriteaof` 命令，会 fork 子进程使用内存里当前的数据重写生成一个文件，然后在子进程生成文件过程中的命令放到一个 AOF 重写缓冲区，子进程完成工作后，主进程再把缓冲区命令写进文件，然后原子的重命名替换原 AOF 文件。

持久化选择：

- 单机 Redis：
  - 4.0版本前：如果想要提供很高的数据可靠性，可以同时开启 RDB 和 AOF；如果可以接受一定的数据丢失，使用 RDB 持久化。
  - 4.0版本后：开启混合持久化。
- 主备 Redis
  - master 不开持久化，保证 master 读写性能；slave 同时开启 RDB 和 AOF（4.0后用混合持久化）。

### 线程模型

线程模型为单进程单线程模式，使用 Reactor 模型，通过 IO 多路复用（epoll）实现。

Redis 主要有两种事件：文件事件、定时事件。在主事件循环里依次执行就绪的文件事件和定时时间，先通过 IO 多路复用获取就绪的文件事件（根据下一个定时事件的开始时间来指定超时时间），然后执行就绪的文件事件，再执行时间事件，时间事件的真实执行时间比指定的要晚一点。

### 事务

通过 `multi/exec/discard/watch` 支持事务。执行 `multi` 后的普通命令入队，收到 `exec/discard` 后再执行或丢弃。

Redis 事务的特性：

- 原子性：命令入队时只进行简单的合法性校验，如果有错误指令，则事务都不执行；但如果开始执行后，某命令出错，会继续往下执行。因此**不保证原子性**，可能部分成功部分失败。
- 隔离性：单进程单线程模型，相当于序列化隔离级别，保证隔离性。
- 持久性：如果开了 AOF 和 `appendfsync` 设为 always 时，保证事务的持久性。
- 一致性：原子性不完全支持，因此不能实现一致性。

由于是缓冲命令到队列中一起执行，因此在事务中不能获取某个值。可以通过 `watch` 支持简单的乐观锁，执行时如果 watch 的 key 被修改了，则事务报错。

## 集群

### 主从架构

Redis 一个 master 节点可以有多个 slave 节点，主从之间通过异步复制来实现数据同步。

Redis 主从复制主要分为同步和命令传播两个阶段：

- 同步阶段：
  - 全量同步：slave 发送 `PSYNC` 命令给 master。如果是首次，或者 slave 的同步进度慢于复制缓冲区的最早命令，进行全量同步。master 生成 RDB 文件发送给 slave，slave 读取 RDB 文件。然后再将期间的复制缓冲区的命令发给 slave。
  - 部分同步：一般在 slave 断网一段时间后重新连上 master，发送 `PSYNC` 命令给 master，如果 master 的复制缓冲区能覆盖到 slave 当前的 offset，则返回 offset 之后的部分数据给 slave。
- 命令传播阶段：master 成为 slave 的客户端，当执行写命令时，则发送一份命令给 slave。

从节点不会主动的删除过期数据，而是通过接收 master 的 DEL 的命令。从节点接到读请求的时候，也会进行过期判断，过期则不返回，但是不会主动进行删除。

主从同步的一些实际问题：

- 复制缓冲区过小，当网络不佳的时候，同步偏移量越界导致频繁的全量复制。可以调大 `repl-backlog-size` 大小。
- 主从数据不一致问题，由于是异步复制，主从不一致不可避免。业务可以对一致性较高的请求去主库查询。

### Sentinel

主从架构只解决了数据的冗余和读写分离，但是不能自动地故障恢复，因此引入了 Sentinel。

Sentinel 主要用来支持单机主从架构的高可用，负责监控主从节点状态、故障转移等，sentinel 本身也可以配置为集群。

Sentinel 与主从节点建立命令连接和订阅连接，订阅连接用于 sentinel 节点之间的互相发现，之后各 sentinel 节点之间也建立命令连接。

Sentinel 向主从节点发送命令检测节点状态，如果超过半数的 sentinel 认为 master 主观下线，则认为主节点客观下线。Sentinel 会使用 Raft 协议进行 leader 选举，然后 sentinel leader 会将 slave 节点中选择心跳正常且数据同步最新的节点提升为 master 节点。

选举切换新的 master 是通过 Redis 命令实现的，不会改变 Redis 的 IP 信息，可以通过配置 `client-reconfig-script` 在迁移时候执行的脚本，完成 VIP 的切换。

### Redis Cluster

Redis cluster 是 Redis 官方提供的集群方案，使用的是服务端 sharding 方案，为了保证高可用，redis cluster 同时也用了主从模型，集群中每个 master 节点可以有一个或多个 slave 节点。

Redis cluster 中只有 master 节点提供读写，slave 节点只用来做数据的同步。Client 与 redis 节点直接连接，不需要中间的 proxy 层。

集群的高可用：

- 集群启动后，通过 `meet` 命令将其他节点拉到集群中。节点之间通过 ping-pong 判断连接状态，通过 gossip 协议传播节点的信息。如果超过半数 ping 某节点没有回应，则集群认为该节点宕机，会广播节点 fail 消息。该 master 的 slave 会开始拉票，只有其他 master 节点可以投票，收到半数票的 slave 升级为新的 master 节点。
- 集群中如果某台 master 挂掉，且该 master 没有 slave，则集群不可用；集群中超过半数 master 挂掉，则集群不可用。

集群的数据分片：

- Redis cluster 中有 `2^14=16384` 个哈希槽，集群中每个节点分配一部分的槽，命令根据 `CRC16(key)%16384` 来确定 key 所在的槽（key 可以使用 hash tag 来只用 tag 信息分槽）。使用哈希槽可以方便的添加和移除节点，并且添加和删除节点时，不会造成集群不可用。
- 客户端访问任意 master 节点即可，如果该槽由其他节点处理，会返回 `MOVED` 给客户端，客户端会再去访问正确的节点。虽然没有要求，但是客户端的最佳实现，最好能够拉取并缓存一份槽的映射表，并且当返回 `MOVED` 时更新缓存结果，提高一次性访问到正确节点的概率。

槽迁移过程中命令处理：

- 在迁移节点 A 和接收节点 B 上分别执行命令，执行后开始进入迁移。每个槽的 key 是逐步迁移的，一个槽会有很多个 key，在迁移过程中，客户端可能需要同时访问两个节点。
- 客户端会发送命令给节点 A，如果 key 存在则返回；如果不存在，且是正在迁移的槽，则 key 可能在节点 B 上，返回 `ASK` 和 B 的地址信息。客户端收到 `ASK` 后再次访问 B 来获取 key。
- `ASK` 只是槽迁移过程中的临时措施，客户端不会缓存 `ASK` 的结果，只对当前这次命令进行转发。

客户端的批量命令处理：

- 批量命令，如 `mget`，如果命令中的 key 属于不同的节点，redis 会返回错误。
- 常见的优化方式：
  - `mget` 拆分为 n 个 `get` 串行/并行执行。
  - `mget` 根据 hash 算法算出对于槽位对应节点后，拆分为最多节点个 `mget` 分别串行/并行请求。
  - 根据业务需要，使用 hashtag 将某些 key 写到同一个节点上。

### Redis 集群方案对比

业界主流的 Redis 集群方案主要有几种：

- Twemproxy：proxy-based，中心节点。
- Codis：proxy-based，中心节点，自动故障恢复、在线扩容。
- Redis Cluster：无中心架构。

客户端分片相当于将路由规则存储在客户端，可以通过 ZK 之类的来推送配置，

Twemproxy 是由 Twitter 开源的集群化方案，是 proxy-based 方案。它的功能比较单一，只做了路由的转发，不支持自动故障恢复和在线扩容。

Codis 是豌豆荚开源的 Redis 集群方案，也是 proxy-based 方案，与 Twemproxy 类似，但是是一整套的高可用方案。Codis 核心组件为：

- codis-proxy：负责请求的路由转发
- codis-dashboard：控制中心，负责转发规则、故障自动恢复、数据在线迁移、节点扩缩容、自动化运维 API 等。
- codis-group：基于 Redis 二次开发的 server，一主多从，增加数据异步迁移功能。通过 Sentinel 检测节点状态，实现高可用。

Codis 的组件挺多，功能很齐全。通过槽位的思路进行请求路由；通过修改 Redis 支持异步迁移等命令，来实现在线扩容。但由于修改了 Redis，使用它必须使用它内置的 Redis，可能无法使用 Redis 的最新特性。Codis 是在 Redis Cluster 还没出现的背景下出现的。

Redis cluster 是 Redis 官方提供的集群方案，本质是无中心化的集群。每个 server 节点都能处理所有请求，通过返回让客户端去重新访问正确的节点，smart client 可以缓存路由表信息。

Redis cluster 和 Proxy-based 方案对比：

- Redis cluster 方案向集群中任何一台节点请求，根据节点返回值做重定向，同时客户端缓存路由表；Proxy-based 方案多一层代理节点访问，存在性能损耗。
- Redis cluster 方案，server 的实现复杂；Proxy-based 方案节点路由等分布式问题可以通过 ZK 来实现。
- Redis cluster 方案，要求实现 smart client，支持 cluster 协议，实现复杂；Proxy-based 使用简单 client 即可。
- Redis cluster 实现了 Redis 集群和高可用；Proxy-based 要避免 proxy 单点问题，需要实现 proxy 集群和高可用，同时还要考虑 Redis 集群的高可用。

## Redis 最佳实践

- 避免使用大 key。
- 将缓存作为可丢失的来用，尽量做到缓存不可用也不会影响业务。
- 设置合理的过期时间。
- 集群使用同一物理机时，注意分配 IO 资源。如 AOF rewrite 时间错开等。

## Redis 各版本核心特性

Redis 3.0：

- Redis Cluster：Redis 集群的官方实现。

Redis 4.0：

- 支持 RDB-AOF 混合持久化，充分用于两者优势。
- PSYNC 优化，更多的场景使用部分复制，而不是全量同步。如重启，存储 serverid。

Redis 5.0：

- 支持 stream 数据结构，类似于 Kafka，提供支持消费者组合持久化的消息队列，使用 radix tree 实现。

Redis 6.0：

- 多线程 IO：通过 IO 线程组来分担处理网络数据的读写，命令的执行和获取就绪的事件还是主线程来执行的。
- 集群代理（Redis Cluster Proxy）：将集群抽象为单个实例，使用简单的 client 就能访问集群，同时也解决了集群下使用 multiple 命令跨 slot 的限制。但是目前的版本还是 unstable 的，而且 proxy 自身没有解决单点问题。
