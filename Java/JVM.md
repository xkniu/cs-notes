# JVM

## JVM 运行时的数据区域

JVM 运行时内存结构为：

- 方法区（Method Area）：虚拟机加载的类信息、常量、静态变量、编译后的代码等，是 JVM 规范的一部分，规范不强制对该区域进行垃圾回收。
- 堆（Heap）：JVM 存放对象实例的地方。
- Java 虚拟机栈（JVM Stack）：每一条线程有自己私有的栈空间，是 Java 方法执行的内存模型。栈帧存储局部变量表、操作数栈、动态链接、方法出口等信息，随方法的调用而创建，结束而销毁。
- 本地方法栈（Native Method Stack）：和虚拟机栈类型，是 native 方法使用的栈空间。
- 程序计数器（PC）：每个线程都有自己的程序计数器，程序计数器记录当前线程执行的字节码地址，当执行的是 native 方法时，程序计数器为空。

这些内存区域中，方法区、堆是线程共享的，虚拟机栈、本地方法栈、程序计数器是线程私有的。

除了以上的 JVM 内部的内存区域，还有直接内存区域：

- 直接内存（Direct Memory）：直接内存是虚拟机内存外的部分。Java NIO 的 DirectByteBuffer 可以使用直接内存的空间，可以避免在内存和 JVM 堆中来回拷贝数据，提升 IO 性能。

根据 JVM 规范，从逻辑上来说，方法区和堆是独立的，但不同的虚拟机可以用不同的具体实现方式。

HotSpot 对方法区的主要实现：

- JDK 7：使用永久代（PermGen）实现，和堆的物理内存是连在一起的，并且垃圾回收是和老年代的垃圾回收绑定在一起的，无论哪个满了都会触发老年代和永久代的回收。
- JDK 8：取消了永久代，使用元空间（Metaspace）实现，元空间使用 JVM 外的本地内存中。

永久代和元空间都能通过参数限制大小，取消永久代的主要原因还是因为 HotSpot 要合并 JRockit 的代码。

JDK 7 中，将类的静态变量和字符串常量池（interned strings）从永久代移到了堆中。

限制不同区域的内存：

- 方法区：
    - JDK 7 使用永久代实现，通过 `-XX:MaxPermSize` 限制永久代最大空间
    - JDK 8 使用元空间实现，通过 `-XX:MaxMetaspaceSize` 限制最大空间，默认没有限制，能使用完所有的机器内存。
- 堆内存：通过 `-Xmx` 和 `-Xms` 来指定堆的最大和最小空间。
- JVM 栈内存：通过 `-Xss` 来设置单个线程的栈空间，所有线程栈能使用的内存为除堆内存和方法区外的内存，因此剩余内存和 `-Xss` 配置限制了最大的线程数量，而 `-Xss` 又限制了单个线程的方法最大调用深度。
- 直接内存：`-XX:MaxDirectMemorySize` 设置能使用的直接内存大小。

## 垃圾回收

判断对象是否可回收的算法：

- 引用计数法：记录对象被引用的次数，为0的时候回收。
    - 优点：实现简单，判断效率高。
    - 缺点：存储计数额外空间开销；每次赋值更新计数器的开销；无法识别循环引用。
- 可达性分析：从根对象集合（GC Roots）为起点，从上到下的方式搜索，确认目标对象是否在引用链上，不在引用链上则为不可达，不可达的对象就为可回收对象。
    - 优点：解决了循环引用问题。
    - 缺点：实现复杂；效率不如引用计数法高。

Java 采用了可达性分析算法；Python 使用了引用计数为主，可达性分析为辅的算法。

Java 可达性分析的 GC Roots 包含哪些对象，其实就是虚拟机中程序运行的“源头”的对象：

- 虚拟机栈帧中引用的对象。
- 本地方法栈中引用的对象。
- 方法区中静态属性、常量引用的对象。

可达性分析中需要判断是否从 GC Roots 引用链可达，Java 中分为四种类型的引用，引用程度从强到弱分别为：

- 强引用（Strong Reference）：代码中普通的引用，强引用存在时对象不能被回收。
- 软引用（Soft Reference）：还有用但是非必须的对象，内存空间不够时，可以回收掉这些对象。常用于内存敏感的缓存。
- 弱引用（Weak Reference）：非必须的对象，下次垃圾回收就回收这些对象。常用于某容器的键是不可重复构造的，那么键的其他引用都已经消亡时，这个容器的键也需要删除的场景。
- 虚引用（Phantom Reference）：虚引用不会影响对象的生存时间，也无法通过虚引用访问这个对象，必须配合 `ReferenceQueue` 使用，用来在这个对象回收前加入到队列中并通知处理。

Java 垃圾回收算法：

- 标记-清除（Mark-Sweep）：标记需要回收的对象，标记完成后统一回收。
    - 优点：不需要使用额外的内存空间，内存利用率高。
    - 缺点：标记和清除效率都不高；会产生大量的内存碎片。
- 复制（Copying）：将可用内存分为两个内存块，每次使用一半的空间，当这部分空间用完时，复制存活的对象到另一半空间。
    - 优点：简单高效，不会出现内存碎片。
    - 缺点：内存利用率低；存活对象过多时效率降低明显，因为需要移动大量的对象。
- 标记-整理（Mark-Compact）：标记需要回收的对象，将存活的对象向内存的一段移动。
    - 优点：内存利用率高；不会出现内存碎片。
    - 缺点：标记和整理效率都不高。

虚拟机通常使用**分代收集算法**，将内存划分为不同的区域进行管理。根据对象存活的生命周期不同，通常分为新生代和老年代，不同的区域使用不同的算法。主要是基于以下事实：

- 绝大部分对象是朝生夕死的。
- 熬过越多次垃圾回收的对象越难消亡。

新生代：

- 新生代使用复制算法，通常只存活下来比较少的对象。
- 通常分为一个 `Eden 区` 和两个 `Survivor 区`（S0、S1），同一时间使用 `Eden 区` 和一个 `Survivor 区` 来分配对象，当空间不足时，将存活的对象拷贝到另一块 `Survivor 区`，交替的使用 S0 和 S1 的空间。如果 `Survivor 区`空间不足则存储到老年代。每被拷贝一次对象的年龄加1，超过阀值后升入老年代。
- 不使用两个完全一样大小的空间，是为了节省空间，因为通常垃圾回收后存活的对象数量很少。默认配置 `–XX:SurvivorRatio` 为 8，即 `Eden:S0:S1 = 8:1:1`。

老年代：

- 老年代通常使用“标记-清除”或“标记-整理”算法。
- 使用“标记-清除”算法的话，可能会因为内存碎片没有足够的内存分配大对象，通常也会搭配“标记-整理”算法使用。

安全点和安全区域：

- 安全点：GC 线程开始枚举 GC Roots 时，需要 Stop The World，暂停用户线程确保引用关系不会变化，它并不会使用抢占式中断，而是设置一个标记位表示希望中断，所有线程运行到Safepoint（安全点）后，主动的中断挂起。JVM 在字节码指令中，插入一些安全点，如方法调用、循环跳转、异常跳转等。
- 安全区域：并非所有的线程都有运行机会，如有些处于 block 状态，则可能一直不会进入安全点，这时就需要 Safe Region（安全区域），即线程确认进入某个区域后，引用关系不会发生变化，在这个区域中任何位置垃圾回收都是安全的。当线程执行到安全区域代码时，会标记自己进入安全区域，这时候 GC 线程就不用管这个线程了，线程想要离开安全区域则需要等待 GC 线程暂停阶段结束的信号。

## 垃圾回收器

HotSpot 在 JDK 7 有7种垃圾收集器。对于垃圾回收器来说，可以从以下两个维度来比较：

- 单线程/多线程：垃圾回收器的垃圾回收线程是一个还是多个。
- 串行/并行：垃圾回收器线程能否和用户线程同时执行。

常用的垃圾回收器：

- `Serial / Serial Old`：都是单线程串行处理器，适合单 CPU 服务器。
- `Parallel Scavenge / Parallel Old`：都是多线程串行处理器，关注吞吐量，适合后台运算类应用。可以通过 `GCTimeRatio` 来调整 GC 时间的占比，关注吞吐量；通过 `MaxGcPauseMills` 来控制最大停顿时间，关注响应时间，通常停顿时间越小，则会增加 GC 次数，从而降低吞吐量。
- `ParNew`：新生代垃圾回收器，多线程串行处理器。是 `Serial` 的多线程版本，会有多个 GC 线程并行。在多核处理器下，效果比 `Serial` 好；单核处理器下，由于线程切换性能反而更差。默认使用 CPU 核心数量的线程，可以通过 `+XX:ParallelGCThreads` 配置。
- `CMS（Concurrent Mark Sweep）`：老年代垃圾回收器，**多线程并行处理器**，并采用了“标记-清除”算法。以最短停顿时间为目标的处理器，适合关注服务响应时间的应用，用户体验好。
- `G1`：JDK 1.7 引入，负责整个堆的垃圾回收，不能和其他回收器搭配使用。不再将堆内存分为整块的年轻代和老年代，而是采用多个大小相等的不同分代的 Region 来管理堆内存。

除了上面的默认搭配外，其他可搭配使用的组合：

- `Serial Old` 可以和其他几个年轻代垃圾回收器搭配使用。
- `CMS` 可以和 `Serial` 和 `ParNew` 搭配使用。

各 JDK 版本的默认垃圾回收器：

- JDK 7/8：`Parallel Scavenge / Parallel Old`
- JDK 9：`G1`

CMS 垃圾回收器，回收过程主要分为4个阶段，其中耗时较长的并发标记和并发清理阶段，都可以和用户线程并行。4个阶段如下：

- 初始标记：标记下 GC Roots 直接关联到的对象，速度很快，需要 STW。
- 并发标记：对堆中的对象进行可达性分析，在整个回收中耗时最长，并行执行，不需要停顿。
- 重新标记：为了修正并发标记过程中，用户线程继续执行导致标记变动的部分对象，进行 STW，然后多线程标记。
- 并发清除：不需要停顿。

CMS 垃圾回收器的优缺点：

- 优点：耗时最长的并发标记和并发清除可以和用户线程一起工作，所以总体来说是和用户线程并行执行的。
- 缺点：CPU 敏感，并发阶段需要占用 CPU 资源；并发清除阶段，用户线程还在执行，还会继续产生浮动垃圾，下次 GC 才能清理掉；由于浮动垃圾的存在，不能在老年代快满的时候再回收，要提前进行回收（默认阀值92%），如果预留的内存不够浮动垃圾，则会使用 Serial Old 代替 CMS；使用的算法是“标记-清除“（因为清除阶段要和用户线程并发，不能进行内存整理），会产生内存碎片。

G1 垃圾收集器：

不再将堆内存分为整块的新生代、老年代，而是把堆划分为多个大小相等的 `Region`（区域），每个 Region 有自己的分代属性。Region 可以分为：新生代、存活代、老年代。

G1 有两种 GC 模式：

- Young GC：关注所有的新生代 Region，通过控制收集的年轻代 Region 个数来控制回收时间。
- Mixed GC：关注所有的新生代 Region，并加上通过预测计算回收收益最大的若干个老年代 Region。

G1 回收主要分为两大部分，这两部分相对独立执行：

- Global concurrent marking：全局并发标记。主要分为四个阶段：
    - 初始标记：需要 STW，扫描根集合。
    - 并发标记
    - 最终标记
    - 清理：并不会真正的清理，而是统计每个 region 的存活对象有多少，并把没有存活对象的 region 放到可分配 region 列表。提供信息判断回收价值最高的region。
- 拷贝存活对象（evacuation）：该阶段需要 STW，它负责把一部分 region 里存活的对象拷贝到空 Region 里去，然后回收原 Region 的空间。它根据自己的根集合遍历来判断对象的生死，不需要依赖 Global concurrent marking 的结果，有就用，没有就算了。

G1 中的 RSet（remember set）：

- 每个 Region 有一个 remember set，是辅助 GC 的结构，典型的空间换时间。在 GC 的时候，对于 `old->young` 和 `old-old` 的跨代对象引用，只需要扫描要回收 region（CSet）中的 RSet 即可，避免需要扫描所有的老年代 region。这个 RSet 的维护是通过 post-write barrier 实现的。

G1 中的 Young GC 和 Mixed GC 都需要 STW，为什么 G1 还是被称为低延迟的实现？

- G1 中只有两步是并发执行的：全局并发标记。G1 虽然会 mark 整个堆，但是并不回收所有的的 region，只选择收益高的 region 来回收。这样暂停的开销就在一定范围内可控，每次暂停的时间跟一般 GC 的 Young GC 类似，所以 G1 标榜为”软实时“（Soft real-time）GC。
- G1 的目标停顿时间可以用 `-XX:MaxGCPauseMillis` 指定，默认为 200ms，这个值不宜设置的过小，因为复制阶段需要 STW，需要时间的，过小会让每次回收的 region 过少，长期可能无法满足垃圾回收的情况，导致退化到 Serial old 进行 GC。

G1 和 CMS 的选择：

- 当堆的大小比较大时，使用 G1 会有更好的效果，分水岭大概在10G左右规模。

ZGC 是 JDK 11 推出的一款低延迟的垃圾回收器，它能支持8M~16TB级别的堆，并且停顿时间不超过10ms，停顿时间不会随着堆的大小增加。

ZGC 使用完全不同的原理来实现，也是采用”标记-复制“算法，它分为以下几个阶段：初始标记、并发标记、再标记、并发转移准备、初始转移、并发转移。ZGC 中只有初始标记、再标记、初始转移三个阶段需要 STW。

ZGC 关键技术：

- 着色指针：将对象存活信息存放在引用对象的指针中，这与传统的垃圾回收放在对象头中完全不同。
- 读屏障：JVM 向应用中插入一小段代码，当应用从堆中读取对象时，会触发这段代码，ZGC 中通过读屏障，当访问的对象正在移动时，等待对象移动完成后（不需要等待 GC 完成，时间很短）再访问。

ZGC 将追踪垃圾回收算法的重点从对象转为引用，将 GC 信息加到引用中，从而使 STW 从所有暂停变为单个引用访问的暂停。ZGC 没有分代概念。

## 虚拟机性能监控工具

常用的命令行工具：

- `jps`：查询机器的 Java 进程，以及进程的启动参数。
- `jinfo`：实时查看和调整目标 JVM 的各项参数。
- `jstat`：查看类加载、JIT 编译、垃圾回收、内存使用等信息。
- `jstack`：查看 Java 进程内的线程堆栈信息，可以用来检测死锁、定位死循环等。
- `jmap`：查看 Java 进程内存使用信息，包括堆的使用情况、堆内对象统计信息、类加载信息。

图形化综合诊断工具：

- `jconsole`：JDK 提供的工具，查看虚拟机状态，堆内存、线程、类等信息。
- `jprofiler`：Java 应用性能诊断工具，可以查看方法调用、内存分配、线程和锁。

## 类加载机制

类加载的生命周期：

- 加载：通过类的全限定名，获取到 class 的字节流；将字节流类的静态存储结构转换为方法区的运行时存储结构；在内存中生成代表该类的 Class 对象。
- 链接：
    - 验证：验证 class 字节流满足虚拟机的规范，保证 class 的正确性，不会危害虚拟机的安全。
    - 准备：为类变量分配内存和设定默认初始值（如 int 初始值为 0）。
    - 解析：将常量池内的符号引用转为直接引用（把类名、方法名、子类名等引用替换为具体的内存地址或者偏移量）。
- 初始化：执行类的构造器方法。如果该类有父类，会先执行父类的 init 在执行子类的 init。

虚拟机规范没有强制什么时候加载类。但是虚拟机规定了，**有且仅有**这些情况下才能初始化类：

- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令。常见场景：创建实例、调用静态方法、访问静态非 final 变量。
- 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候。
- 初始化一个类时，如果父类没有初始化则先进行父类的初始化。
- 虚拟机启动时，执行指定主类的初始化。
- JDK 1.7 动态语言支持 MethodHandle 实例解析结果对应的方法句柄所对应的类。

这五种会造成类初始化的场景称为对一个类的**直接引用**，其他引用类的方式叫做**间接引用**，都不会触发类的初始化。

## 类加载器

Java 中主要包括以下类加载器：

- Bootstrap ClassLoader：使用 C++ 实现，嵌套在 JVM 内部，**没有父加载器**。用来加载 Java 的核心类库，如 *rt.jar*、*resource.jar*
- Extension ClassLoader：Java 语言编写，继承自 `java.lang.ClassLoader`，**父加载器为 Bootstrap ClassLoader**。从 *java.ext.dirs* 目录加载类库。
- Application ClassLoader：Java 语言编写，继承自 `java.lang.ClassLoader`，**父加载器为 Extension ClassLoader**。用来加载 *classpath* 下的类库，是程序中的默认加载器。
- 自定义加载器：如果以上的类加载器不能满足我们的要求，可以实现自定义加载器，比如从网络加载 Java 类，处理传输安全加解密等。

两个类相等，要求类本身相等并且类加载器相等。相当于每个类加载器有自己独立的命名空间。

类加载机制，双亲委派机制：

- 如果一个类加载器收到一个加载请求，它先不自己加载，而是先把请求委托给父加载器执行，父加载器递归的向上委托加载，直到 **Bootstrap ClassLoader**。如果父加载器可以完成加载任务，则返回成功；如果父加载器加载失败，则由子类自己尝试去加载，加载失败则抛出 ClassNotFoundException 异常。
- 系统提供的3个类加载器之间是通过双亲委派模式实现的，主要优点避免类的重复加载，避免核心类被篡改。
- 双亲委派机制是一种软约束，用户实现自定义类加载器时，建议这样实现，但是不是强制的。

除了双亲委派机制，还有一些其他的类加载模式。OSGI 类加载模式：

- OSGI 是一个 Java 语言的动态模块化规范。其中每个模块叫做 bundle，一般也以 jar 包封装。但是一个 bundle 能够声明它依赖的 package 和它导出到的 package。每个 bundle 会使用是一个 ClassLoader，他们之间是平级的一个有向图，根据配置的依赖和导出，委派给对应的加载器和进行权限控制。OSGI 的优点是可以动态的加载、卸载 bundle，每个 bundle 是独立的可复用单元。另外 OSGI 还可以用来实现加载多个版本的类的问题。

Java 9 也开始支持模块化，通过 Java Platform Module System 来实现：

- 为什么需要模块化？class 是 JVM 的最小可执行文件，为了方便管理，使用 jar 包来打包多个 class 文件。但通常我们并不需要 jar 包里的所有 class，因此引入模块化的概念，主要就是解决依赖关系。
- Java 9 的模块化没有使用多个类加载器来实现，不同模块都在一个类加载器中，但是引入了额外的隔离规则来检查，从而保证加载的类有正确的权限。

## 编译优化

Java 的三种主要编译模式：

- 前端编译：将 java 文件编译为 class 文件的过程，
- JIT（Just in Time）：及时编译器，后端编译。Java 更注重这部分的优化。
- AOT（Ahead of Time Compiler）：直接把 Java 编译成本地代码运行，编译不占用运行时间。JDK 9 开始引入，但是由于 Java 的动态语言特性，不是所有的字节码都能够编译执行，而且编译后的代码与平台相关，降低了可移植性。

JIT 优化检测的原理：

- HotSpot Detection（热点代码预测）：把执行频率高的代码，实时的编译成本地代码。热点预测主要是通过插入方法调用计数器和循环回边计数器来找到调用次数较多的方法和循环，编译成本地代码版本。

HotSpot 中有两个 JIT 编译器：

- Client Compiler，简称 C1，只进行简单的、可靠地优化，优化较少，但是编译速度快。
- Server Compiler，简称 C2，会开启一些编译时间较长的优化，并根据统计信息做一些激进的优化。

解析器和编译器共同执行的模式叫 MixedMode：

- 使用 `-Xint` 强制 JVM 运行在解释模式，JIT 编译器不介入。
- 使用 `-Xcomp` 强制 JVM 运行在编译模式，优先使用编译。

在 Java 7 之前，需要用户根据服务器性质去选择编译器，对于不会长期运行的服务，采用编译效率比较高的 C1，对于长期运行的服务，或对峰值性能有要求的服务，采用峰值性能更好的 C2。Java 7 引入了分层编译的概念，JDK 8 默认开启分层编译，它结合了 C1 和 C2 的优势，JVM 自动的判断代码使用 C1 还是 C2 编译。

编译优化：

- 方法内联
- 逃逸分析：确认对象不会逃逸后，可以栈上分配对象，锁消除等。
- 循环展开
- 数组边界检查消除
