# 分布式事务

## CAP & BASE 理论

CAP 理论，分布式系统不能同时满足 C（Consistency）A（Availability）P（Partition Tolerance），最多只能同时满足两项。

- 一致性：所有节点的数据在同一时间是一致的。比如客户端写入值v0，在另外一个节点读取到的也是v0.
- 可用性：服务在正常响应时间内返回“正确”的结果。
- 分区容错性：当分布式系统出现网络分区时，仍然能对外提供满足可用性或者一致性的服务。

CAP 理论中，C、A、P 并非完全平等的。无法通过降低 CA 来提升 P，P 只能通过提升基础设施来提高稳定性。对于分布式系统来说，P 是一个基本的客观事实，CAP 三者中，只能在 CA 间做权衡。

- CA without P：如果要求不出现 P（网络分区），则 CA 是能够同时满足的，但 P 是分布式系统的自然事实，如果舍弃 P，则只能是单机的系统。
- CP without A：如果不要求 A（可用），当出现 P（网络分区）时，要求各个节点同步数据达到 C（强一致），会导致同步时间无限延长而不可用。如 HBase、Zookeeper。
- AP without C：如果不要求 C（强一致），当出现 P（网络分区）时，节点之间可能失去联系，使用本地的数据提供服务，保证 A（高可用），但可能会返回过期的数据。如 Eureka、Redis 主从、MySQL 主从异步复制。

C/A 不是一个 0/1 的选择，C 指的是强一致性，如果适当的放宽对一致性的要求，可以在 CA 之间进行更细粒度的权衡。

BASE 理论是 BA（Basically Available）、S（Soft State）、E（Eventually Consistent）三个词的缩写，是对 CAP 中的一致性和可用性权衡的结果。

- BA：基本可用。指分布式出现故障的时候，允许损失部分可用性，保证核心服务可用。如非核心功能降级，响应适当变慢等。
- S：软状态。允许系统存在中间状态，且中间状态不影响系统的整体可用性。如允许不同节点的数据副本同步存在延时。
- E：最终一致性。系统中的数据副本经过一定时间后，最终能达到一个一致的状态。

## 分布式事务解决方案

分布式事务指的在分布式系统中实现事务，事务操作跨越多个节点，它是由多个本地事务组合而成。

柔性事务：遵循 BASE 理论，保证最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。

### 2PC

2PC（Two-phase Commit，两阶段提交），将事务拆分为两个阶段来处理：准备阶段和提交阶段。事务的发起者成为协调者，事务的执行者成为参与者。协调者需要了解所有参与者的状态，来决定参与者要进行提交还是回滚。

主要流程如下：

- 准备阶段：协调者向所有参与者发送 prepare 请求，参与者写入 redo 和 undo 信息，返回协调者是否可以提交。
- 提交阶段：协调者如果收到所有参与者 prepare 成功，则向所有参与者发送 commit；协调者如果收到有参与者 prepare 失败，则向所有参与者发送 cancel。

方案总结：

- 性能问题：提交阶段，参与者处理同步阻塞状态，锁定了资源无法释放。
- 可靠性问题：如果协调者存在单点故障，协调者故障后所有参与者资源处理锁定状态。
- 一致性问题：如果提交阶段，局部发生网络问题，则存在节点数据不一致。

XA 是数据库提供的 2PC 接口协议，基于数据库的 XA 协议来实现 2PC 又称为 XA 方案。主要抽象了三个角色：AP（应用程序），发起事务操作；RM（资源管理器），控制分支事务；TM（事务管理器），控制全局事务。

### 3PC

3PC（Three-phase Commit，三阶段提交），是 2PC 的改进版本，在参与者和协调者中都引入了超时机制。

三阶段将二阶段的 prepare 拆分为两个阶段：canCommit 和 preCommit。

- canCommit 阶段：协调者向所有参与者发送 canCommit 请求，询问参与者是否可以提交。
- preCommit 阶段：协调者如果收到所有参与者回复 canCommit 成功，协调者向所有参与者发送 preCommit，参与者写入 redo 和 undo 信息，返回协调者是否可以提交；协调者如果收到有参与者 canCommit 失败，则终止。
- doCommit 阶段：协调者收到所有的参与者 preCommit 成功，则向所有参与者发送 doCommit。协调者如果收到有参与者 preCommit 失败，或者超时没有收到结果，协调者向所有的参与者发送 abort。如果参与者在收到 preCommit 请求后，一直没有收到 doCommit 请求，则超时后自动提交。

方案总结：

- 优点：减少了阻塞的范围，第二阶段后才会锁定资源。避免了资源锁定无法释放，引入了协调者和参与者超时。
- 缺点：
    - 数据不一致问题还是存在。在第三阶段，如果某些参与者无法和协调者通信，超时会提交事务。如果协调者最终中断事务，则会出现数据不一致。
    - 比 2PC 的通信流程复杂，增加了一次 RPC 交互。

### TCC

TCC 是业务层面的分布式事务。和 2PC 交互流程类似，只是接口的维度是针对业务而不是具体的数据资源。

- Try：资源的预留和锁定。
- Confirm：确认执行业务操作，真正地使用资源。
- Cancel：取消执行业务操作，解锁释放资源。

TCC 需要处理的一些异常场景：

- 允许空回滚：因为网络等原因，可能 try 超时，这时候事务管理器会进行 cancel。服务应该能处理没有收到 try 的 cancel 请求，返回成功。
- 防悬挂控制：因为网络拥堵原因，发生空回滚后，即收到 cancel 后，才收到延迟过来的 try，这时需要能够识别并且拒绝请求，而不是锁定资源，避免出现悬挂。
- 幂等控制：无论是网络的重传还是事务的补偿，try/confirm/cancel 都可能会被重复的执行。要对重复的操作返回成功。

方案总结：

- 要求业务接口提供 Try/Confirm/Cancel 的配套接口，对业务侵入性较强，实现复杂。
- TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高的场景。

### 本地消息表

本地消息表，来源于 eBay 的分布式事务方案。整体流程如下：

- 在业务事务的同一个事务中，写入本地的消息表。由于使用的是同一个事务，消息表和业务事务保证一致性。
- 业务事务成功后，发送本地消息表到消息队列。同时提供一个补偿线程扫描本地消息表，异步发送“可能没有成功发送“的消息，可能会重复发送。发送成功后回更状态。
- 消费端接受消息后进行处理，需要支持幂等消费。

本地消息表的适用场景和局限性：

- 调用采用了异步化，只适用于调用方不关注调用结果的场景，例如预期多次重试最终一定能成功的场景。
- 最终一致性模型，在消息还没被消费并处理成功前，调用方和被调用方处理不一致的状态。

消息发送可以扩展为通用的 RPC 调用，只需要保持调用需要的上下文和参数信息即可。

## 分布式事务框架

### Seata

Seata 是阿里中间件团队开源的一个分布式事务框架，支持以下几种事务模式：

- AT 模式
- TCC 模式
- SAGA 模式
- XA 模式

Seata 框架的核心角色：

- TC (Transaction Coordinator)：事务协调者，维护全局事务和分支事务的状态，驱动全局事务的提交或回滚。
- TM (Transaction Manager)：事务管理器，开始全局事务、提交或者回滚全局事务。
- RM (Resource Manager)：资源管理器，管理分支事务处理资源，与 TC 交互注册分支事务和报告分支事务状态，驱动分支事务的提交或回滚。

其中 TM、RM 通过 SDK 提供，业务服务直接通过包引入。TC 单独部署为独立的集群。

Seata 的事务模式（AT、TCC、XA）：

1. TM 向 TC 发起 Begin、Commit、Rollback 全局事务。
2. TM 把代表全局事务的 XID 绑定到分支事务上。
3. RM 向 TC 注册，把分支事务关联到 XID 的全局事务上。
4. RM 把分支事务的执行结果上报给 TC。（可选）
5. TC 发送分支提交或者分支回滚命令给 RM。

#### 各事务模式

AT 模式是一种无侵入的分布式方案。在 AT 模式下，用户只需要关注自己的“业务 SQL”，用户的“业务 SQL”作为一阶段，Seata 框架自动生成二阶段的提交和回滚操作。

AT 模式的两阶段提交：

- 一阶段：将业务数据和回滚日志在同一个本地事务中提交。
- 二阶段：
    - 提交：异步化，快速返回给 TC 成功，之后异步的删除回滚日志。
    - 回滚：根据第一阶段的日志进行反向补偿。

AT 模式的数据隔离：

- 写隔离：一阶段事务提交前，必须要先调用 TC 拿到数据的全局锁，锁信息维护在 TC。避免最后事务回滚，导致其他事务的脏写。
- 读隔离：默认的隔离级别是 `READ_UNCOMMITTED`，如果必须要 `READ_COMMITTED` 隔离级别，则需要执行 `SELECT FOR UPDATE`，这时会向 TC 申请全局锁，如果无法获取，则释放本地锁并重试，直到全局锁拿到，才能返回数据（即读取的数据是在分布式事务中已提交的）。

AT 模式的优缺点：

- 优点：
    - 无侵入，业务只需要关注自己的 SQL。
    - 无需数据库支持 XA 协议。
    - 并发和吞吐量高，本地锁在第一阶段就可以释放。
- 缺点：
    - 只能用在支持事务的关系型数据库中。
    - 隔离级别最多支持到读已提交，SQL 解析不能涵盖所有语法。

TCC 模式也是两阶段提交模型，不依赖于底层数据资源的事务支持，每个接口需要提供 Try/Confirm/Cancel 一套的接口，提供业务维度的资源锁定、提交和回滚操作。

TCC 模式的优缺点：

- 优点：
    - 可以支持各种资源，如缓存之类的。
- 缺点：
    - 业务侵入比较高，每个接口需要提供 TCC 需要的三个接口。

Saga 模式是长事务的解决方案，该模式下每个参与者都提交本地事务，当一个参与者失败时，则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务提供。

Saga 模式适用场景为业务流程多，业务流程长。参与者有遗留系统，不适合进行 TCC 改造的。

Saga 模式的优缺点：

- 优点：
    - 一阶段直接提交本地事务，无锁，高性能。
    - 事件驱动框架，参与者可异步处理，高吞吐。
    - 补偿服务容易实现。
- 缺点：
    - 不保证隔离性，一阶段提交的本地事务本质上已经对所有参与者可见，后续回滚则相当于读未提交。

由于 Saga 缺少隔离性，在极端情况下可能无法回滚。如A账户充值，B账户扣减余额，B失败后需要回滚A，但是可能已经被用户消费掉了。业务设计的时候应该遵循原则”宁可长款, 不可短款“，即宁可先多收用户钱再退回，少了钱可能就追不回来了。

XA 模式，利用事务资源对 XA 协议的支持，使用 Seata 的事务模式，以 XA 协议的机制来管理分布式事务。接入 Seata 的事务模式后，XA 模式的使用与 AT 模式完全相同，也对业务无侵入。

为什么支持 XA？

- 全局一致性：其他的事务机制本质都是补偿型事务，事务资源的隔离性不能完全支持，无法做到全局一致性；而 XA 是事务资源本身提供协议支持的，能够做到任意视角的有效隔离，满足全局一致性。

XA 和 AT 的对比：

- AT 模式相当于是自实现的 XA 事务，在 SQL 解析支持上一定是不如事务资源原生支持的 XA，并且隔离性不如 XA。但 AT 的所有锁都有 TC 维护，锁释放不需要 TM 参与，释放非常快，并且事务提交阶段可以异步化。

参考文档：

- Seata 各事务模式：<http://seata.io/zh-cn/docs/dev/mode/at-mode.html>
- 分布式事务如何实现？深入解读 Seata 的 XA 模式：<http://seata.io/zh-cn/blog/seata-xa-introduce.html>